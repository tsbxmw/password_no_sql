---
layout: post
title: 排序算法 (2)
categories: C
description: 笔记
keywords: c, sort
---

常见的排序算法

##  排序算法 (2)

### 插入类排序法

* 插入排序(Insertion Sort)的基本思想是：每次将一个待排序的记录，按其关键字大小插入到前面已经排好序的子文件中的适当位置，直到全部记录插入完成为止。

> 插入排序一般意义上有两种：直接插入排序和希尔排序，下面分别介绍

#### 直接插入排序

> 基本概念：

  最基本的操作是将第i个记录插入到前面i-1个以排好序列的记录中。具体过程是：将第i个记录的关键字K依次与其前面的i-1个已经拍好序列的记录进行比较。将所有大于K的记录依次向后移动一个位置，直到遇到一个关键字小于或等于K的记录，此时它后面的位置必定为空，则将K插入。

> 例子：

    初始序列 ： [12] 15   9   20   6   31   24
                      |
    一次排序 ： [12  15]  9   20   6   31   24
                <---------|
    二次排序 ： [9   12  15]  20   6   31   24
                               |
    三次排序 ： [9   12  15   20]  6   31   24
                <------------------|
    四次排序 :  [6   9   12   15   20] 31   24
                                        |
    五次排序 ： [6   9   12   15   20  31]  24
                                        <---|
    六次排序 ： [6   9   12   15   20  24   31]

> C 实现：

```c

    void InsertSort(int arr[], int n)
    {
    int temp;
    int i,j;
    for (int i = 1; i < arr.Length; i++)    
            {    
                int temp = arr[i];    
                int j = i;    
                while ( (j > 0) && (arr[j - 1] > t) )    
                {    
                    arr[j] = arr[j - 1];//交换顺序    
                    --j;    
                }    
                arr[j] = temp;    
            }   
                   
    }
```

> 性能分析

>  1．算法的时间性能分析

　对于具有n个记录的文件，要进行n-1趟排序。
  各种状态下的时间复杂度：
  初始文件状态       正序         反序        无序(平均)
  字比较次数          1             i+1         （i-2）/2
  总关键字比较次数 n-1         (n+2)(n-1)/2 ≈n2/4
  第i趟记录移动次数 0           i+2           （i-2）/2
  总的记录移动次数 0           (n-1)(n+4)/2 ≈n2/4
  时间复杂度      0（n）      O（n2）        O（n2）

  注意：
　  初始文件按关键字递增有序，简称"正序"。
　  初始文件按关键字递减有序，简称"反序"。

>  2．算法的空间复杂度分析

　  算法所需的辅助空间是一个监视哨，辅助空间复杂度S(n)=O(1)。是一个就地排序。

>  3．直接插入排序的稳定性

　  直接插入排序是稳定的排序方法。

* 直接插入排序法，针对少量的数据项排序，速度比较快，数据越大，这中方法的劣势也就越明显了。

#### 折半插入排序  binary insertion sort

> 基本思想：

  折半插入排序（binary insertion sort）是对插入排序算法的一种改进，由于排序算法过程中，就是不断的依次将元素插入前面已排好序的序列中。由于前半部分为已排好序的数列，这样我们不用按顺序依次寻找插入点，可以采用折半查找的方法来加快寻找插入点的速度。

> 实现：

  在将一个新元素插入已排好序的数组的过程中，寻找插入点时，将待插入区域的首元素设置为a[low],末元素设置为a[high]，则轮比较时将待插入元素与a[m],其中m=(low+high)/2相比较,如果比参考元素小，则选择a[low]到a[m-1]为新的插入区域(即high=m-1)，否则选择a[m+1]到a[high]为新的插入区域（即low=m+1），如此直至low<=high不成立，即将此位置之后所有元素后移一位，并将新元素插入a[high+1]。

> C实现

```c
   
    void BInsertSort(int data[],int n)
    {
       int low,high,mid;
       int temp,i,j;
       for(i=1;i<n;i++)
       {
            low=0;
            temp=data[i];// 保存要插入的元素
            high=i-1;
            while(low<=high) //折半查找到要插入的位置
            {                       
                  mid=(low+high)/2;
                  if(data[mid]>temp)
                  high=mid-1;
                  else
                  low=mid+1;
            }
            int j = i;    
            while ((j > low) && (arr[j - 1] > t))    
            {    
                arr[j] = arr[j - 1];//交换顺序    
                --j;    
            }    
            arr[low] = temp;  
       }
    }
```

> 性能分析

  折半插入排序算法是一种稳定的排序算法，比直接插入算法明显减少了关键字之间比较的次数，因此速度比直接插入排序算法快，但记录移动的次数没有变，所以折半插入排序算法的时间复杂度仍然为O(n^2)，与直接插入排序算法相同。
  附加空间O(1)。

### LINK
  [ sort - 3 ](https://tsbxmw.github.io/2016/12/08/C-sortnum-3/)